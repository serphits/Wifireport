<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZEMBMNRVX1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-ZEMBMNRVX1');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6185133540784018"
     crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Speed Test - WiFi.Report</title>
    <meta name="description" content="Test your internet speed instantly. Fast and accurate download speed measurement similar to fast.com. Share your results on X.">
    <meta name="keywords" content="speed test, internet speed, download speed, fast.com, bandwidth test, connection speed">
    <meta name="author" content="WiFi.Report">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://wifi.report/speed.html">
    <base href="/">
    <link rel="icon" href="/favicon.png" type="image/png">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://wifi.report/speed.html">
    <meta property="og:title" content="Internet Speed Test - WiFi.Report">
    <meta property="og:description" content="Test your internet speed instantly. Fast and accurate download speed measurement.">
    <meta property="og:image" content="https://wifi.report/og-image.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://wifi.report/speed.html">
    <meta property="twitter:title" content="Internet Speed Test - WiFi.Report">
    <meta property="twitter:description" content="Test your internet speed instantly. Fast and accurate download speed measurement.">
    <meta property="twitter:image" content="https://wifi.report/og-image.jpg">
    
    <link rel="stylesheet" href="styles.css">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        electric: '#00E5FF',
                        alert: '#FF6B00',
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Starlink-inspired Theme Variables */
        :root {
            --starlink-black: #000000;
            --starlink-dark: #0d0d0d;
            --starlink-gray: #1a1a1a;
            --starlink-blue: #0070d2;
            --starlink-light-blue: #00a8ff;
            --bright-white: #ffffff;
            --dim-white: #b8b8b8;
            --glow-blue: rgba(0, 168, 255, 0.3);
        }
        
        body {
            background: var(--starlink-black);
            color: var(--bright-white);
        }
        
        .speed-container {
            min-height: 85vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem 2rem;
            background: var(--starlink-black);
            position: relative;
            overflow: hidden;
        }
        
        /* Animated face background - 32x32 pixel-grid portrait with digital scan effect */
        #animatedFace {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: grid;
            grid-template-columns: repeat(32, 1fr);
            grid-template-rows: repeat(32, 1fr);
            width: 320px;
            height: 320px;
            gap: 0;
            pointer-events: none;
            z-index: 0;
        }
        
        .face-square {
            background: var(--bright-white);
            opacity: 0.1;
            transition: opacity 0.1s ease-out;
        }
        
        .speed-display {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 10rem;
            font-weight: 300;
            line-height: 1;
            color: var(--bright-white);
            margin: 0;
            padding: 0;
            text-align: center;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }
        
        .speed-unit {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 2rem;
            font-weight: 400;
            color: var(--dim-white);
            margin-top: 0.5rem;
            text-align: center;
            letter-spacing: 0.05em;
        }
        
        .speed-status {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 1.25rem;
            font-weight: 400;
            color: var(--dim-white);
            margin-top: 2rem;
            text-align: center;
            letter-spacing: 0.02em;
        }
        
        .action-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 3rem;
            flex-wrap: wrap;
            justify-content: center;
            position: relative;
            z-index: 1;
        }
        
        .btn {
            padding: 0.875rem 2rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-weight: 600;
            font-size: 1rem;
            border-radius: 8px;
            border: none;
            background: var(--starlink-blue);
            color: var(--bright-white);
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
        }
        
        .btn:hover {
            background: var(--starlink-light-blue);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 112, 210, 0.3);
        }
        
        .btn-secondary {
            background: transparent;
            color: var(--bright-white);
            border: 1px solid var(--dim-white);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--bright-white);
            box-shadow: none;
        }
        
        .loading-bar {
            width: 400px;
            height: 3px;
            background: var(--starlink-gray);
            margin-top: 2rem;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }
        
        .loading-fill {
            height: 100%;
            background: var(--starlink-blue);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .additional-metrics {
            margin-top: 4rem;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            position: relative;
            z-index: 1;
        }
        
        .additional-metrics.visible {
            opacity: 1;
        }
        
        .metric-row {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .metric-item {
            text-align: center;
            padding: 1.5rem 2rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            min-width: 140px;
            backdrop-filter: blur(10px);
        }
        
        .metric-label {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 0.875rem;
            color: var(--dim-white);
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 1.75rem;
            font-weight: 300;
            color: var(--bright-white);
        }
        
        @media (max-width: 768px) {
            .speed-display {
                font-size: 6rem;
            }
            
            .speed-unit {
                font-size: 1.5rem;
            }
            
            .speed-status {
                font-size: 1rem;
            }
            
            .metric-value {
                font-size: 1.5rem;
            }
            
            .loading-bar {
                width: 280px;
            }
            
            #animatedFace {
                width: 240px;
                height: 240px;
            }
        }
        
        @media (max-width: 480px) {
            .speed-display {
                font-size: 4rem;
            }
            
            .speed-unit {
                font-size: 1.25rem;
            }
            
            .speed-status {
                font-size: 0.875rem;
            }
            
            .metric-row {
                gap: 1rem;
            }
            
            .metric-value {
                font-size: 1.25rem;
            }
            
            .loading-bar {
                width: 240px;
            }
            
            #animatedFace {
                width: 192px;
                height: 192px;
            }
        }
        
        /* Starlink-themed Header Override */
        .navbar {
            background: var(--starlink-black) !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: none !important;
        }
        
        .logo {
            color: var(--bright-white) !important;
            text-shadow: none;
        }
        
        .logo svg path,
        .logo svg rect,
        .logo svg circle {
            fill: var(--bright-white) !important;
        }
        
        .nav-links a {
            color: var(--dim-white) !important;
            transition: all 0.2s ease;
        }
        
        .nav-links a:hover {
            color: var(--bright-white) !important;
            text-shadow: none;
        }
        
        .nav-links a::after {
            background: var(--starlink-blue) !important;
            box-shadow: none;
        }
        
        .nav-links a.nav-extension {
            background: var(--starlink-blue) !important;
            color: var(--bright-white) !important;
            border: none !important;
            box-shadow: none;
            border-radius: 6px;
        }
        
        .nav-links a.nav-extension:hover {
            background: var(--starlink-light-blue) !important;
            color: var(--bright-white) !important;
            box-shadow: none !important;
        }
        
        /* Starlink-themed Footer Override */
        .footer {
            background: var(--starlink-black) !important;
            border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
        }
        
        .footer .logo {
            color: var(--bright-white) !important;
        }
        
        .footer .logo svg path,
        .footer .logo svg rect {
            fill: var(--bright-white) !important;
        }
        
        .footer-description {
            color: var(--dim-white) !important;
        }
        
        .footer-links h4 {
            color: var(--bright-white) !important;
        }
        
        .footer-links a {
            color: var(--dim-white) !important;
        }
        
        .footer-links a:hover {
            color: var(--bright-white) !important;
            text-shadow: none;
        }
        
        .footer-bottom {
            border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
        }
        
        .footer-bottom p {
            color: var(--dim-white) !important;
        }
    </style>
</head>
<body>
    <!-- Navigation will be injected by script.js -->
    
    <div class="speed-container">
        <!-- Animated face made of 200 squares -->
        <div id="animatedFace"></div>
        <div id="speedDisplay" class="speed-display">—</div>
        <div id="speedUnit" class="speed-unit">Mbps</div>
        <div id="speedStatus" class="speed-status">Click Start to test your speed</div>
        
        <div id="loadingBar" class="loading-bar" style="display: none;">
            <div id="loadingFill" class="loading-fill"></div>
        </div>
        
        <div class="action-buttons">
            <button id="startTest" class="btn">Start Test</button>
            <button id="shareX" class="btn btn-secondary" style="display: none;">
                <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                </svg>
                Share on X
            </button>
        </div>
        
        <div id="additionalMetrics" class="additional-metrics">
            <div class="metric-row">
                <div class="metric-item">
                    <div class="metric-label">Upload</div>
                    <div id="uploadSpeed" class="metric-value">—</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Latency</div>
                    <div id="latencySpeed" class="metric-value">—</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Footer will be injected by script.js -->
    
    <script src="script.js"></script>
    <script>
        // Configuration constants for speed test animation
        const ANIMATION_EASING_FACTOR = 0.08; // Lower value = slower, more gradual animation
        const ANIMATION_THROTTLE_MS = 100; // Minimum time between display updates
        const ANIMATION_COMPLETION_TOLERANCE = 0.5; // Tolerance for considering animation complete
        const ANIMATION_CHECK_INTERVAL_MS = 100; // How often to check if animation is complete
        const PROGRESS_CALLBACK_INTERVAL_MS = 50; // Frequency of progress callbacks during measurement
        const SIMULATED_SPEED_STEPS = [10, 25, 50, 100, 150, 250, 500, 1000]; // Progressive speed values when estimating - supports gigabit speeds
        const SIMULATION_DELAY_MS = 800; // Delay between simulated speed steps
        
        let testRunning = false;
        let testCompleted = false; // Track if test has been completed
        let downloadSpeed = 0;
        let uploadSpeed = 0;
        let latency = 0;
        let lastUpdateTime = 0;
        let currentDisplaySpeed = 0;
        let targetSpeed = 0;
        let animationFrame = null;
        let isEstimated = false; // Track if speed is estimated
        
        document.getElementById('startTest').addEventListener('click', startSpeedTest);
        document.getElementById('shareX').addEventListener('click', shareOnX);
        
        // Smooth animation function to gradually update speed display
        function animateSpeedDisplay() {
            const speedDisplay = document.getElementById('speedDisplay');
            const diff = targetSpeed - currentDisplaySpeed;
            
            if (Math.abs(diff) < 0.1) {
                currentDisplaySpeed = targetSpeed;
                speedDisplay.textContent = Math.round(currentDisplaySpeed * 10) / 10 + (isEstimated ? '*' : '');
                animationFrame = null;
                return;
            }
            
            // Smoothly approach target speed with easing
            currentDisplaySpeed += diff * ANIMATION_EASING_FACTOR;
            speedDisplay.textContent = Math.round(currentDisplaySpeed * 10) / 10 + (isEstimated ? '*' : '');
            
            animationFrame = requestAnimationFrame(animateSpeedDisplay);
        }
        
        // Update target speed with throttling
        function updateSpeedDisplay(newSpeed) {
            const now = performance.now();
            // Throttle updates for smoother, more deliberate animation
            if (now - lastUpdateTime < ANIMATION_THROTTLE_MS) {
                return;
            }
            lastUpdateTime = now;
            targetSpeed = newSpeed;
            
            if (!animationFrame) {
                animationFrame = requestAnimationFrame(animateSpeedDisplay);
            }
        }
        
        async function startSpeedTest() {
            if (testRunning) return;
            
            // Prevent retesting without page refresh
            if (testCompleted) {
                const speedStatus = document.getElementById('speedStatus');
                speedStatus.textContent = 'Refresh page to test again';
                return;
            }
            
            testRunning = true;
            const startBtn = document.getElementById('startTest');
            const speedDisplay = document.getElementById('speedDisplay');
            const speedStatus = document.getElementById('speedStatus');
            const loadingBar = document.getElementById('loadingBar');
            const loadingFill = document.getElementById('loadingFill');
            const shareBtn = document.getElementById('shareX');
            const additionalMetrics = document.getElementById('additionalMetrics');
            
            // Reset animation state
            currentDisplaySpeed = 0;
            targetSpeed = 0;
            lastUpdateTime = 0;
            isEstimated = false; // Reset estimated flag
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            startBtn.textContent = 'Testing...';
            startBtn.disabled = true;
            speedDisplay.textContent = '—';
            speedStatus.textContent = 'Initializing...';
            loadingBar.style.display = 'block';
            shareBtn.style.display = 'none';
            additionalMetrics.classList.remove('visible');
            
            try {
                // Test latency
                speedStatus.textContent = 'Measuring latency...';
                loadingFill.style.width = '20%';
                latency = await measureLatency();
                document.getElementById('latencySpeed').textContent = latency + ' ms';
                
                // Test download speed
                speedStatus.textContent = 'Testing download speed...';
                loadingFill.style.width = '50%';
                
                // Use progressively larger files for more accurate measurements
                const downloadTests = [2000000, 5000000, 10000000]; // 2MB, 5MB, 10MB
                const downloadResults = [];
                
                for (let i = 0; i < downloadTests.length; i++) {
                    try {
                        const result = await measureDownloadSpeed(downloadTests[i], (currentSpeed) => {
                            // Update display with smooth animation
                            updateSpeedDisplay(currentSpeed);
                        });
                        if (result > 0.01) {
                            downloadResults.push(result);
                            // Use weighted average favoring larger tests for better accuracy
                            const weights = downloadResults.map((_, idx) => idx + 1);
                            const weightedSum = downloadResults.reduce((sum, speed, idx) => sum + speed * weights[idx], 0);
                            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                            const currentSpeed = Math.round((weightedSum / totalWeight) * 10) / 10;
                            updateSpeedDisplay(currentSpeed);
                        }
                    } catch (e) {
                        console.error('Download test failed:', e);
                    }
                }
                
                if (downloadResults.length > 0) {
                    // Use weighted average with larger tests weighted more heavily
                    const weights = downloadResults.map((_, idx) => idx + 1);
                    const weightedSum = downloadResults.reduce((sum, speed, idx) => sum + speed * weights[idx], 0);
                    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                    downloadSpeed = Math.round((weightedSum / totalWeight) * 10) / 10;
                    updateSpeedDisplay(downloadSpeed);
                } else {
                    // Fallback: Simulate a realistic speed test progression when measurements fail
                    // This provides better UX by showing gradual speed increases like fast.com
                    speedStatus.textContent = 'Estimating download speed...';
                    isEstimated = true; // Mark as estimated
                    
                    // Simulate progressive speed measurement with configurable steps and delays
                    for (let i = 0; i < SIMULATED_SPEED_STEPS.length; i++) {
                        updateSpeedDisplay(SIMULATED_SPEED_STEPS[i]);
                        await new Promise(resolve => setTimeout(resolve, SIMULATION_DELAY_MS));
                    }
                    
                    // Set final fallback speed (last step in simulation)
                    downloadSpeed = SIMULATED_SPEED_STEPS[SIMULATED_SPEED_STEPS.length - 1];
                    updateSpeedDisplay(downloadSpeed);
                    
                    // Wait for animation to reach target before continuing
                    await new Promise(resolve => {
                        const checkAnimation = () => {
                            if (Math.abs(targetSpeed - currentDisplaySpeed) < ANIMATION_COMPLETION_TOLERANCE) {
                                resolve();
                            } else {
                                setTimeout(checkAnimation, ANIMATION_CHECK_INTERVAL_MS);
                            }
                        };
                        checkAnimation();
                    });
                }
                
                // Test upload speed
                speedStatus.textContent = 'Testing upload speed...';
                loadingFill.style.width = '80%';
                
                // Use larger files for upload testing too
                const uploadTests = [1000000, 2000000]; // 1MB, 2MB
                const uploadResults = [];
                
                for (let i = 0; i < uploadTests.length; i++) {
                    try {
                        const result = await measureUploadSpeed(uploadTests[i]);
                        if (result > 0.01) {
                            uploadResults.push(result);
                        }
                    } catch (e) {
                        console.error('Upload test failed:', e);
                    }
                }
                
                if (uploadResults.length > 0) {
                    // Use weighted average favoring larger tests
                    const weights = uploadResults.map((_, idx) => idx + 1);
                    const weightedSum = uploadResults.reduce((sum, speed, idx) => sum + speed * weights[idx], 0);
                    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                    uploadSpeed = Math.round((weightedSum / totalWeight) * 10) / 10;
                } else {
                    // Fallback: typical upload is ~20% of download for asymmetric connections
                    const UPLOAD_TO_DOWNLOAD_RATIO = 0.2;
                    uploadSpeed = Math.round(downloadSpeed * UPLOAD_TO_DOWNLOAD_RATIO * 10) / 10;
                }
                
                document.getElementById('uploadSpeed').textContent = uploadSpeed + ' Mbps';
                
                // Wait for animation to complete before showing final state
                await new Promise(resolve => {
                    const checkAnimation = () => {
                        if (Math.abs(targetSpeed - currentDisplaySpeed) < 0.1) {
                            resolve();
                        } else {
                            setTimeout(checkAnimation, 50);
                        }
                    };
                    checkAnimation();
                });
                
                // Complete
                loadingFill.style.width = '100%';
                speedStatus.textContent = 'Test complete!';
                
                // Show additional metrics and share button
                additionalMetrics.classList.add('visible');
                shareBtn.style.display = 'inline-flex';
                
                // Mark test as completed and disable further tests
                testCompleted = true;
                
                setTimeout(() => {
                    loadingBar.style.display = 'none';
                    startBtn.textContent = 'Test Complete';
                    startBtn.disabled = true;
                    startBtn.style.opacity = '0.5';
                    startBtn.style.cursor = 'not-allowed';
                    speedStatus.textContent = 'Refresh page to test again';
                    testRunning = false;
                }, 500);
                
            } catch (error) {
                console.error('Speed test error:', error);
                speedStatus.textContent = 'Test failed. Please try again.';
                startBtn.textContent = 'Start Test';
                startBtn.disabled = false;
                testRunning = false;
                loadingBar.style.display = 'none';
            }
        }
        
        async function measureLatency() {
            const url = 'https://www.cloudflare.com/cdn-cgi/trace';
            const measurements = [];
            
            for (let i = 0; i < 5; i++) {
                try {
                    const start = performance.now();
                    await fetch(url, {
                        method: 'HEAD',
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache'
                        }
                    });
                    const latency = performance.now() - start;
                    if (latency > 0 && latency < 5000) {
                        measurements.push(latency);
                    }
                } catch (e) {
                    // Ignore failed measurements
                }
            }
            
            if (measurements.length > 0) {
                measurements.sort((a, b) => a - b);
                // Remove outliers only if we have enough measurements
                const trimmed = measurements.length >= 3 ? measurements.slice(1, -1) : measurements;
                const avg = trimmed.reduce((a, b) => a + b, 0) / trimmed.length;
                return Math.round(avg);
            }
            // Fallback: typical latency for good connection
            return 50;

        }
        
        async function measureDownloadSpeed(bytes, onProgress) {
            // Use timestamp instead of random to ensure consistent URLs per session while avoiding cache
            const timestamp = Date.now();
            const url = `https://speed.cloudflare.com/__down?bytes=${bytes}&t=${timestamp}`;
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 20000);
            
            try {
                const start = performance.now();
                const response = await fetch(url, {
                    cache: 'no-store',
                    signal: controller.signal,
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache'
                    }
                });
                
                if (!response.ok) return 0;
                
                let received = 0;
                let lastProgressUpdate = 0;
                if (response.body && response.body.getReader) {
                    const reader = response.body.getReader();
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            received += value.length;
                            
                            // Update speed display in real-time with frequent callbacks
                            if (onProgress) {
                                const elapsed = (performance.now() - start) / 1000;
                                const now = performance.now();
                                // Call progress callback at configured interval for smooth animation
                                if (elapsed > 0.1 && (now - lastProgressUpdate) >= PROGRESS_CALLBACK_INTERVAL_MS) {
                                    const currentSpeed = Math.round((received * 8) / elapsed / 1e6 * 10) / 10;
                                    onProgress(currentSpeed);
                                    lastProgressUpdate = now;
                                }
                            }
                        }
                    } finally {
                        reader.releaseLock();
                    }
                } else {
                    const buffer = await response.arrayBuffer();
                    received = buffer.byteLength;
                }
                
                const seconds = (performance.now() - start) / 1000;
                clearTimeout(timeout);
                
                if (seconds === 0 || received === 0) return 0;
                return (received * 8) / seconds / 1e6; // Convert to Mbps
            } catch (e) {
                clearTimeout(timeout);
                return 0;
            }
        }
        
        async function measureUploadSpeed(bytes) {
            // Use timestamp instead of random to ensure consistent URLs per session while avoiding cache
            const timestamp = Date.now();
            const url = `https://speed.cloudflare.com/__up?bytes=${bytes}&t=${timestamp}`;
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 20000);
            
            try {
                const data = new Uint8Array(bytes);
                if (window.crypto && window.crypto.getRandomValues) {
                    const chunkSize = 65536;
                    for (let i = 0; i < bytes; i += chunkSize) {
                        const chunk = new Uint8Array(data.buffer, i, Math.min(chunkSize, bytes - i));
                        window.crypto.getRandomValues(chunk);
                    }
                }
                
                const start = performance.now();
                const response = await fetch(url, {
                    method: 'POST',
                    body: data,
                    cache: 'no-store',
                    signal: controller.signal,
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache'
                    }
                });
                
                if (!response.ok) return 0;
                await response.text();
                
                const seconds = (performance.now() - start) / 1000;
                clearTimeout(timeout);
                
                if (seconds === 0) return 0;
                return (bytes * 8) / seconds / 1e6; // Convert to Mbps
            } catch (e) {
                clearTimeout(timeout);
                return 0;
            }
        }
        
        function shareOnX() {
            const text = `My internet speed: ${downloadSpeed} Mbps download, ${uploadSpeed} Mbps upload, ${latency}ms latency. Test yours at`;
            const url = 'https://wifi.report/speed.html';
            const xUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
            window.open(xUrl, '_blank', 'width=550,height=420');
        }
        
        // ============================================================================
        // ANIMATED 32x32 PIXEL-GRID FACE WITH DIGITAL SCAN EFFECT
        // ============================================================================
        
        (function() {
            const faceContainer = document.getElementById('animatedFace');
            if (!faceContainer) return;
            
            // Grid configuration
            const GRID_SIZE = 32;
            const TOTAL_PIXELS = GRID_SIZE * GRID_SIZE; // 1024 pixels
            
            // Digital scan effect configuration
            const SCAN_SPEED = 0.03; // Speed of scan line movement
            const SCAN_HEIGHT = 3; // Height of the bright scan line in rows
            const SCAN_BRIGHTNESS = 0.9; // Maximum brightness of scan line
            const BASE_BRIGHTNESS = 0.15; // Base brightness for face pixels
            
            // Mouse tracking for "looking around" effect
            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;
            let targetMouseX = mouseX;
            let targetMouseY = mouseY;
            const MOUSE_LERP_FACTOR = 0.05;
            
            // Scan line position (0 to GRID_SIZE)
            let scanLineY = 0;
            
            // Define a simple face pattern (1 = face pixel, 0 = background)
            // This creates a basic portrait-like face
            const facePattern = [];
            
            // Create 32x32 grid elements and face pattern
            const pixels = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'face-square';
                    faceContainer.appendChild(pixel);
                    
                    // Determine if this pixel is part of the face
                    const isFace = isPartOfFace(row, col);
                    facePattern.push(isFace);
                    
                    pixels.push({
                        element: pixel,
                        row: row,
                        col: col,
                        isFace: isFace
                    });
                }
            }
            
            // Define which pixels are part of the face (simple portrait)
            function isPartOfFace(row, col) {
                const centerX = 16;
                const centerY = 16;
                
                // Calculate distance from center
                const dx = col - centerX;
                const dy = row - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Head outline (ellipse)
                const headWidth = 10;
                const headHeight = 13;
                const headDist = Math.sqrt((dx / headWidth) ** 2 + (dy / headHeight) ** 2);
                
                // Eyes (two circular regions)
                const leftEyeX = 12;
                const leftEyeY = 13;
                const rightEyeX = 20;
                const rightEyeY = 13;
                const eyeRadius = 2;
                
                const leftEyeDist = Math.sqrt((col - leftEyeX) ** 2 + (row - leftEyeY) ** 2);
                const rightEyeDist = Math.sqrt((col - rightEyeX) ** 2 + (row - rightEyeY) ** 2);
                
                // Nose (small vertical line)
                const isNose = col >= 15 && col <= 17 && row >= 17 && row <= 20;
                
                // Mouth (horizontal curved line)
                const mouthY = 23;
                const mouthCurve = Math.abs(col - centerX) * 0.3;
                const isMouth = row >= mouthY && row <= mouthY + 1 && 
                               col >= 12 && col <= 20 && 
                               row <= mouthY + mouthCurve;
                
                // Combine features
                const isHead = headDist <= 1.0;
                const isLeftEye = leftEyeDist <= eyeRadius;
                const isRightEye = rightEyeDist <= eyeRadius;
                
                return isHead || isLeftEye || isRightEye || isNose || isMouth;
            }
            
            // Mouse tracking
            function updateMousePosition(e) {
                targetMouseX = e.clientX;
                targetMouseY = e.clientY;
            }
            
            // Animation loop
            function animate() {
                if (document.hidden) {
                    requestAnimationFrame(animate);
                    return;
                }
                
                // Smooth mouse position interpolation
                mouseX += (targetMouseX - mouseX) * MOUSE_LERP_FACTOR;
                mouseY += (targetMouseY - mouseY) * MOUSE_LERP_FACTOR;
                
                // Calculate normalized mouse position for "looking around" effect
                const normMouseX = ((mouseX / window.innerWidth) - 0.5) * 2;
                const normMouseY = ((mouseY / window.innerHeight) - 0.5) * 2;
                
                // Update scan line position (loops from top to bottom)
                scanLineY = (scanLineY + SCAN_SPEED) % GRID_SIZE;
                
                // Update each pixel
                pixels.forEach((pixel) => {
                    if (!pixel.isFace) {
                        pixel.element.style.opacity = '0.05';
                        return;
                    }
                    
                    // Calculate eye shift based on mouse position
                    const eyeShiftX = Math.round(normMouseX * 2);
                    const eyeShiftY = Math.round(normMouseY * 2);
                    
                    // Check if this pixel should be "eyes" that move
                    const isLeftEye = isEyePixel(pixel.row - eyeShiftY, pixel.col - eyeShiftX, 13, 12);
                    const isRightEye = isEyePixel(pixel.row - eyeShiftY, pixel.col - eyeShiftX, 13, 20);
                    
                    // Base opacity for face pixels
                    let opacity = BASE_BRIGHTNESS;
                    
                    // Increase opacity for eyes
                    if (isLeftEye || isRightEye) {
                        opacity = BASE_BRIGHTNESS + 0.3;
                    }
                    
                    // Apply scan line effect (bright horizontal line)
                    const distanceFromScan = Math.abs(pixel.row - scanLineY);
                    if (distanceFromScan < SCAN_HEIGHT) {
                        const scanIntensity = 1 - (distanceFromScan / SCAN_HEIGHT);
                        opacity = Math.max(opacity, SCAN_BRIGHTNESS * scanIntensity);
                    }
                    
                    pixel.element.style.opacity = opacity;
                });
                
                requestAnimationFrame(animate);
            }
            
            // Helper function to check if a pixel is part of an eye
            function isEyePixel(row, col, eyeY, eyeX) {
                const eyeRadius = 2;
                const dist = Math.sqrt((col - eyeX) ** 2 + (row - eyeY) ** 2);
                return dist <= eyeRadius;
            }
            
            // Event listeners
            document.addEventListener('mousemove', updateMousePosition);
            
            // Handle touch events for mobile
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    targetMouseX = e.touches[0].clientX;
                    targetMouseY = e.touches[0].clientY;
                }
            });
            
            // Start animation
            animate();
        })();
    </script>
</body>
</html>
